/************************************************************************************************************
 * Util functions for adding colors to clusters.
 * (these functions could be moved to the backend, actually, it would be better, if they would be there.)
 * 
***************************************************************************************************************/

"use strict";

import {
    is_numbering_in_range, siblings, round_float, init_drag, undefinedClusterColorHex
} from './generic_utils.js';


//....................................................FUNCTIONS.............................................................................


/**
 * Generates vibrant and evenly spaced colors based on the number of steps and the
 * current step.
 * Source: https://stackoverflow.com/questions/1484506/random-color-generator
 * @param {Integer} numOfSteps - The `numOfSteps` parameter in the `rainbow` function represents the total number
 * of steps or intervals you want to divide the color spectrum into. This parameter determines how many
 * distinct colors will be generated by the function.
 * @param {Integer} step - The `step` parameter in the `rainbow` function represents the current step or position
 * in the color spectrum. It is used to calculate the color based on the total number of steps
 * (`numOfSteps`) provided to generate a vibrant and evenly spaced color.
 * @returns {String} color_code returns a hexadecimal color code.
 */
const rainbow = (numOfSteps, step) => {
    var r, g, b;
    var h = step / numOfSteps;
    var i = ~~(h * 6);
    var f = h * 6 - i;
    var q = 1 - f;
    switch(i % 6){
        case 0: r = 1; g = f; b = 0; break;
        case 1: r = q; g = 1; b = 0; break;
        case 2: r = 0; g = 1; b = f; break;
        case 3: r = 0; g = q; b = 1; break;
        case 4: r = f; g = 0; b = 1; break;
        case 5: r = 1; g = 0; b = q; break;
    }
    var color_code = "#" + ("00" + (~ ~(r * 255)).toString(16)).slice(-2) + ("00" + (~ ~(g * 255)).toString(16)).slice(-2) + ("00" + (~ ~(b * 255)).toString(16)).slice(-2);

    return (color_code);
};

/** Shuffles an array in place. Durstenfeld shuffle, optimized version of the Fisherâ€“Yates shuffle algorithm
* Source: https://stackoverflow.com/questions/2450954/how-to-randomize-shuffle-a-javascript-array
* @param {Array} array - array to be shuffled
*/
function shuffleArray(array) {
    for (let i = array.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [array[i], array[j]] = [array[j], array[i]];
    }
}

/**
 * Converts a hexadecimal color code to its corresponding RGB values.
 * Source: https://stackoverflow.com/questions/5623838/rgb-to-hex-and-hex-to-rgb
 * @param {String} hex - The `hex` parameter is a string representing a hexadecimal color code.
 * @returns {Object} result - object with properties `r`, `g`, and `b` representing
 * the red, green, and blue values respectively of the given hexadecimal color code. If the input is
 * not a valid hexadecimal color code, the function returns `null`.
 */
const hexToRgb = (hex) => {
    var result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
    return result ? {
        r: parseInt(result[1], 16),
        g: parseInt(result[2], 16),
        b: parseInt(result[3], 16)
    } : null;
};

/**
 * Generates a color (in hex) for each cluster inside the bounding_boxes_json object. Used in image processing and post-processing views.
 * @param {Object} bounding_boxes - containing the information on images and boxes
 * @param {Object} transcription_json - containing the cluster_id to transcription mapping
 * @param {String} PATH_TO_PHP - path from executing php to fetched php (save_json.php)
 * @return {Promise} - once the colors are entered into the bounding_boxes and it is synchronized with the server,
 * then the promise will resolve by returning the "local_transcription_json".
 */
const AssociateColorsWithClusters = (project_id, save_id, bounding_boxes, transcription_json, PATH_TO_PHP="save_json.php") => {
    return new Promise((resolve, reject) => {
        console.log("AssociateColorsWithClusters starts");

        // ? the entire function could probably be rewritten in a better way

        let local_transcription_json = {};
        //bit of hacking to convert the array - on the off-chance that somehow it became an array - into an object
        local_transcription_json["transcriptions"] = structuredClone({...transcription_json["transcriptions"]});

        // First, get the number of clusters by iterating over the entire bounding_boxes
        let numberOfClusters = 0;

        let array_cluster_id = [];

        Object.keys(bounding_boxes["documents"]).forEach(key => {
            bounding_boxes["documents"][key].forEach((box, sub_index) => {
                if(box.hasOwnProperty("cluster_id") && !array_cluster_id.includes(box["cluster_id"])){
                    array_cluster_id.push(box["cluster_id"]);
                }
            });
        });

        // filter out special clusters
        const filtered_array_cluster_id = array_cluster_id.filter(e => !(e === "-1" || e === "-2"));
        const filtered_transcription_array = Object.keys(local_transcription_json["transcriptions"]).filter(e => !(e === "-1" || e === "-2"));
        const ENOUGH_CLUSTERS = filtered_array_cluster_id.length <= filtered_transcription_array.length ? true : false;

        const transcription_with_color_properties = Object.keys(local_transcription_json["transcriptions"]).filter(key => local_transcription_json["transcriptions"][key].hasOwnProperty("color"));
        const DOES_EVERY_CLUSTER_HAS_COLOR = Object.keys(local_transcription_json["transcriptions"]).length === transcription_with_color_properties.length ? true : false;

        const ARE_FIXED_CLUSTERS_PRESENT = local_transcription_json["transcriptions"].hasOwnProperty("-1") && local_transcription_json["transcriptions"].hasOwnProperty("-2");

        console.log("Are there enough clusters? ",ENOUGH_CLUSTERS, filtered_array_cluster_id, filtered_transcription_array);
        console.log("Does every cluster has a color? ", DOES_EVERY_CLUSTER_HAS_COLOR);
        console.log("Are the fixed clusters present? ", ARE_FIXED_CLUSTERS_PRESENT); // this actually should never be false, only through some error. So this is a fail-safe check.


        // * if every cluster has a color and there are at least as many clusters inside the transcription.json as inside the bounding_boxes.json
        if(DOES_EVERY_CLUSTER_HAS_COLOR && ENOUGH_CLUSTERS && ARE_FIXED_CLUSTERS_PRESENT){
            resolve(local_transcription_json); // here we just send back the variable without change
            console.log("no change in transcription.json");
        }
        else{


            if(!ENOUGH_CLUSTERS){
            

                numberOfClusters = array_cluster_id.length;
    
                if(array_cluster_id.includes("-1")){
                    numberOfClusters--;
                }
                if(array_cluster_id.includes("-2")){
                    numberOfClusters--;
                }
    
                // init a default transcription object
                local_transcription_json["transcriptions"] = {};
    
                array_cluster_id.forEach((elem, i) => {
                    local_transcription_json["transcriptions"][elem] = {
                        "transcription": ""
                    };
                });
    
            }
            else{

                numberOfClusters = Object.keys(local_transcription_json["transcriptions"]).length;
                
            }
            
            // ! duplicating the template_transcription.json, be careful that they don't diverge
            local_transcription_json["transcriptions"]["-1"] = {
                "transcription": "space",
                "color": "#ff0092"
            };
            local_transcription_json["transcriptions"]["-2"] = {
                "transcription": "?",
                "color": undefinedClusterColorHex
            };
    
            console.log(local_transcription_json);
    
            
            // Second, generate a color for each cluster
            let tempColorArray = [];
            let counterRed = 0; //check how many "red-ish" colors are there to later cut them out
    
            for (let index = 0; index < numberOfClusters; index++) {
                tempColorArray.push(rainbow(numberOfClusters, index)); 
            }
    
            tempColorArray.forEach(element => {
    
                const rgbCodedColor = hexToRgb(element);
                if(rgbCodedColor.r > 200 && rgbCodedColor.b < 150 && rgbCodedColor.g < 150){
                    counterRed++;
                }
            });
    
            tempColorArray = [];
    
            for (let index = 0; index < numberOfClusters + counterRed; index++) {
                tempColorArray.push(rainbow(numberOfClusters + counterRed, index)); 
            }
    
            tempColorArray.forEach((element, index) => {
                const rgbCodedColor = hexToRgb(element);
                //it seems that if fewer red colors get generated so we cut usually one less then we should, which is not a problem at this point
                if(rgbCodedColor.r > 200 && rgbCodedColor.b < 150 && rgbCodedColor.g < 150 && tempColorArray.length > numberOfClusters){
                    
                    tempColorArray.splice(index, 1);
                }
            });
    
            shuffleArray(tempColorArray);
    
            console.log(tempColorArray);
    
            console.log(Object.keys(local_transcription_json["transcriptions"]).filter(key => !(key === "-1" || key === "-2")))
    
            //Third, enter generated colors into the transcription_json
            // we filter out the two special clusters, their entries are already complete
            Object.keys(local_transcription_json["transcriptions"]).filter(key => !(key === "-1" || key === "-2")).forEach((key, i) => {
                local_transcription_json["transcriptions"][key]["color"] = tempColorArray[i];
            });
    
    
            console.log(local_transcription_json);
    
            const payload_to_server = {
                "bounding_boxes": bounding_boxes,
                "transcription": local_transcription_json,
                "project_id": project_id,
                "save_id": save_id
    
            };
    
            //Finally, synchronize json-s with server and once it is done, resolve the promise
            fetch(PATH_TO_PHP, { //save_json.php
                method: 'POST', 
                headers: {'Content-Type': 'application/json'},
                body: JSON.stringify(payload_to_server)
            }).then(response => {
                return response.json()
            }).then(data => {
                console.log("AssociateColorsWithClusters ends", data);
                resolve(local_transcription_json);
            });   
        }
    });    
};



export {

    AssociateColorsWithClusters, rainbow, shuffleArray, hexToRgb

};